<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤ë§ˆíŠ¸ ì»·íŒ… í”Œëœ (Smart CP) - ê¸¸ì´ ì •ë ¬ íŒ¨ì¹˜</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');
        
        body { font-family: 'Noto Sans KR', sans-serif; }
        
        @media print {
            @page { 
                size: A4 portrait; 
                margin: 5mm; 
            }
            body { 
                background: white; 
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                zoom: 0.9;
            }
            .print\:hidden { display: none !important; }
            .print\:p-0 { padding: 0 !important; }
            .print\:text-xs { font-size: 10px !important; }
            
            table { width: 100% !important; border-collapse: collapse; page-break-inside: auto; }
            th, td { border: 1px solid #9ca3af !important; padding: 4px 2px !important; white-space: nowrap; }
            tr { page-break-inside: avoid; page-break-after: auto; }
            .break-before-page { page-break-before: always; }
            
            aside { display: none; }
            main { margin-left: 0 !important; padding: 0 !important; width: 100% !important; }
        }
        
        .custom-scrollbar::-webkit-scrollbar { height: 8px; width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        
        .modal-fade-in { animation: fadeIn 0.2s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <div id="root"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, deleteDoc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        window.FirebaseSDK = {
            initializeApp,
            getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken,
            getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, deleteDoc, setDoc, getDoc
        };

        window.dispatchEvent(new Event('firebase-sdk-ready'));
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, memo, useCallback } = React;

        // --- Icons ---
        const IconWrapper = ({ children, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );
        const Trash2 = (props) => <IconWrapper {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconWrapper>;
        const Save = (props) => <IconWrapper {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></IconWrapper>;
        const Plus = (props) => <IconWrapper {...props}><path d="M5 12h14"/><path d="M12 5v14"/></IconWrapper>;
        const Calculator = (props) => <IconWrapper {...props}><rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="14" y2="18"/><path d="M16 10h.01"/><path d="M12 10h.01"/><path d="M8 10h.01"/><path d="M12 14h.01"/><path d="M8 14h.01"/><path d="M12 18h.01"/><path d="M8 18h.01"/></IconWrapper>;
        const Settings = (props) => <IconWrapper {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconWrapper>;
        const Database = (props) => <IconWrapper {...props}><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></IconWrapper>;
        const FileSpreadsheet = (props) => <IconWrapper {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/></IconWrapper>;
        const FileDown = (props) => <IconWrapper {...props}><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"/><polyline points="14 2 14 8 20 8"/><path d="M2 15h10"/><path d="M9 18l3-3-3-3"/></IconWrapper>;
        const Building = (props) => <IconWrapper {...props}><rect x="4" y="2" width="16" height="20" rx="2" ry="2" /><path d="M9 22v-4h6v4" /><path d="M8 6h.01" /><path d="M16 6h.01" /><path d="M8 10h.01" /><path d="M16 10h.01" /><path d="M8 14h.01" /><path d="M16 14h.01" /><path d="M8 18h.01" /><path d="M16 18h.01" /></IconWrapper>;
        const Layers = (props) => <IconWrapper {...props}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></IconWrapper>;
        const X = (props) => <IconWrapper {...props}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></IconWrapper>;
        const Check = (props) => <IconWrapper {...props}><polyline points="20 6 9 17 4 12"></polyline></IconWrapper>;

        // --- Constants ---
        const UNIT_WEIGHT_DATA = {
            "100-100-3.2": 9.52,
            "100-100-3.0": 8.96,
            "100-100-2.3": 6.95,
            "100-100-2.1": 6.37,
            "100-50-2.1": 4.72,
            "75-75-2.1": 4.72,
            "50-50-2.1": 3.07
        };

        const STANDARD_STOCKS = {
            "default": [6000, 6600, 7200, 8000],
            "100x100": { 
                "2.1": [6000, 6600, 7200, 8000], 
                "2.3": [6000, 6600, 7200, 8000], 
                "3.0": [6000, 6200, 7200, 8000], 
                "3.2": [6000, 6200, 7200, 8000] 
            },
            "75x75": { 
                "2.1": [6000, 6600, 7200, 8000], 
                "2.3": [6000, 6600, 7200, 8000], 
                "3.0": [6000, 6200, 7200, 8000], 
                "3.2": [6000, 6200, 7200, 8000] 
            },
            "100x50": { 
                "2.1": [6000, 6600, 7200, 8200],
                "2.3": [6000, 6600, 7200, 8200],
                "3.0": [6000, 6600, 7200, 8200],
                "3.2": [6000, 6600, 7200, 8200] 
            },
            "50x50": { 
                "2.1": [6000],
                "2.3": [6000],
                "3.0": [6000],
                "3.2": [6000]
            }
        };

        // --- Sidebar (Memoized) ---
        const Sidebar = memo(({ viewMode, setViewMode, projectInfo, setProjectInfo }) => {
            const handleTextChange = useCallback((e, field) => {
                setProjectInfo(prev => ({...prev, [field]: e.target.value}));
            }, [setProjectInfo]);

            const handleCheckChange = useCallback((e, field) => {
                setProjectInfo(prev => ({...prev, [field]: e.target.checked}));
            }, [setProjectInfo]);

            return (
                <div className="w-64 bg-white border-r border-gray-200 h-screen flex flex-col fixed left-0 top-0 z-30 print:hidden">
                    <div className="p-6 border-b">
                        <h1 className="text-xl font-bold flex items-center gap-2 text-blue-700">
                            <Calculator className="text-blue-600"/> Smart CP
                        </h1>
                        <p className="text-xs text-gray-400 mt-1">Ver 10.1.0 (Scoring System)</p>
                    </div>
                    <div className="p-4 space-y-4 flex-1 overflow-y-auto">
                        <div className="space-y-2">
                            <label className="text-xs font-bold text-gray-500">í”„ë¡œì íŠ¸ ì •ë³´</label>
                            <input className="w-full p-2 border rounded text-sm bg-gray-50 focus:bg-white transition" placeholder="ì—…ì²´ëª…" value={projectInfo.company} onChange={e => handleTextChange(e, 'company')} />
                            <input className="w-full p-2 border rounded text-sm bg-gray-50 focus:bg-white transition" placeholder="í˜„ì¥ëª…" value={projectInfo.site} onChange={e => handleTextChange(e, 'site')} />
                            <input className="w-full p-2 border rounded text-sm bg-gray-50 focus:bg-white transition" placeholder="ê¸°íƒ€ì‚¬í•­ (ë©”ëª¨)" value={projectInfo.note} onChange={e => handleTextChange(e, 'note')} />
                            <div className="flex flex-col gap-1 mt-2">
                                <label className="flex items-center gap-2 text-xs cursor-pointer"><input type="checkbox" checked={projectInfo.isIronBanding} onChange={e => handleCheckChange(e, 'isIronBanding')} /> ì² ë°´ë”© ë™í‘œê¸°</label>
                                <label className="flex items-center gap-2 text-xs cursor-pointer"><input type="checkbox" checked={projectInfo.isUnder1Ton} onChange={e => handleCheckChange(e, 'isUnder1Ton')} /> 1í†¤ ë¯¸ë§Œ ë°´ë”©</label>
                            </div>
                        </div>
                        <div className="space-y-1">
                            <button onClick={()=>setViewMode('input')} className={`w-full text-left px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 ${viewMode==='input' ? 'bg-blue-50 text-blue-700' : 'text-gray-600 hover:bg-gray-50'}`}><FileSpreadsheet size={16}/> ë°ì´í„° ì…ë ¥</button>
                            <button onClick={()=>setViewMode('result')} className={`w-full text-left px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 ${viewMode==='result' ? 'bg-blue-50 text-blue-700' : 'text-gray-600 hover:bg-gray-50'}`}><Calculator size={16}/> CP ê²°ê³¼ í™•ì¸</button>
                            <button onClick={()=>setViewMode('history')} className={`w-full text-left px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 ${viewMode==='history' ? 'bg-blue-50 text-blue-700' : 'text-gray-600 hover:bg-gray-50'}`}><Database size={16}/> ì €ì¥ ëª©ë¡</button>
                        </div>
                    </div>
                </div>
            );
        });

        // --- Dong Tabs ---
        const DongTabs = ({ dongs, currentDong, setCurrentDong, addDong, deleteDong, renameDong }) => (
            <div className="flex gap-2 mb-4 overflow-x-auto pb-2 border-b items-center print:hidden">
                {dongs.map(dong => (
                    <div key={dong} className="relative group">
                        <button onDoubleClick={() => renameDong(dong)} onClick={() => setCurrentDong(dong)} className={`px-4 py-2 rounded-t-lg font-bold text-sm whitespace-nowrap transition pr-8 ${currentDong === dong ? 'bg-white border-x border-t border-gray-200 text-blue-600 relative top-[1px]' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'}`}>
                            <span className="flex items-center gap-2"><Building size={14}/> {dong}</span>
                        </button>
                        <div className={`absolute right-1 top-1/2 -translate-y-1/2 flex gap-1 ${currentDong === dong ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'} transition`}>
                            <button onClick={(e) => { e.stopPropagation(); deleteDong(dong); }} className="p-0.5 text-gray-400 hover:text-red-500 rounded"><Trash2 size={10}/></button>
                        </div>
                    </div>
                ))}
                <button onClick={addDong} className="px-3 py-2 text-gray-400 hover:text-blue-600 font-bold text-sm bg-gray-50 rounded hover:bg-blue-50 transition"><Plus size={16}/></button>
            </div>
        );

        // --- Input View ---
        const InputView = ({ 
            currentDong, dongs, setCurrentDong, addDong, deleteDong, renameDong,
            data, updateCurrentData, activeTab, setActiveTab, customStocks, setCustomStocks,
            processGridData, handlePaste, runAllDongs, globalSettings,
            isUserStockMode, setIsUserStockMode, userStockList, setUserStockList
        }) => {
            const [inputMode, setInputMode] = useState('sales');
            const [newStd, setNewStd] = useState({ w:'100', h:'100', t:'2.1', length: 6000, qty: 10 });
            const [newRem, setNewRem] = useState({ w:'100', h:'100', t:'2.1', length: 0, qty: 1 });

            useEffect(() => {
                if (inputMode === 'sales') {
                    updateCurrentData({ colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' } });
                } else {
                    updateCurrentData({ colMapping: { 2: 'width', 3: 'height', 4: 'thickness', 5: 'length', 7: 'qty', 8: 'marking' } });
                }
            }, [inputMode]);

            const getSpecOptions = () => {
                const options = [];
                Object.keys(globalSettings).forEach(key => {
                    if (Array.isArray(globalSettings[key])) {
                        if(key !== "default") options.push({label: key, value: key + "|2.1"});
                    } else {
                        Object.keys(globalSettings[key]).forEach(subKey => {
                            options.push({label: `${key} ${subKey}T`, value: `${key}|${subKey}`});
                        });
                    }
                });
                return options;
            };

            const getStandardLengthsForInput = (w, h, t) => {
                const dims = [parseInt(w), parseInt(h)].sort((a,b)=>b-a);
                const specKey = `${dims[0]}x${dims[1]}`;
                const thickStr = String(t).trim();
                const settings = globalSettings;
                if (settings[specKey]) {
                    if (settings[specKey][thickStr]) return settings[specKey][thickStr];
                    if (thickStr === '2.3' && settings[specKey]['2.1']) return settings[specKey]['2.1']; 
                    if (settings[specKey]['all']) return settings[specKey]['all'];
                }
                return settings["default"] || [];
            };

            const handleCellChange = (rIdx, cIdx, val) => {
                const newData = [...data.gridData];
                newData[rIdx][cIdx] = val;
                updateCurrentData({ gridData: newData });
            };

            const handleAddUserStock = (type) => {
                const stock = type === 'std' ? newStd : newRem;
                if(!stock.length || stock.length <= 0 || !stock.qty || stock.qty <= 0) {
                    alert("ê¸¸ì´ì™€ ìˆ˜ëŸ‰ì„ ì˜¬ë°”ë¥´ê²Œ ì…ë ¥í•˜ì„¸ìš”."); return;
                }
                setUserStockList([...userStockList, { ...stock, id: Date.now(), type }]);
            };

            return (
                <div className="animate-fade-in">
                    <div className="flex justify-between items-end mb-2">
                        <h2 className="text-lg font-bold text-gray-800">ë°ì´í„° ì…ë ¥ ({currentDong})</h2>
                        <div className="flex gap-2">
                            <button onClick={runAllDongs} className="bg-gray-800 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-gray-900 flex gap-2 items-center transition"><Layers size={16}/> ì „ì²´ ë™ ê³„ì‚°</button>
                            <button onClick={processGridData} className="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-blue-700 flex gap-2 items-center transition"><Calculator size={16}/> í˜„ì¬ ë™ ê³„ì‚°</button>
                        </div>
                    </div>
                    <DongTabs dongs={dongs} currentDong={currentDong} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} />
                    
                    <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                        <div className="lg:col-span-1 space-y-4">
                             <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-3 flex items-center gap-2 text-sm"><Settings size={16}/> ì…ë ¥ ì–‘ì‹ ì„ íƒ</h3>
                                <div className="flex bg-gray-100 p-1 rounded-lg">
                                    <button onClick={()=>setInputMode('sales')} className={`flex-1 py-2 text-xs font-bold rounded ${inputMode==='sales'?'bg-white shadow text-blue-600':'text-gray-500'}`}>ì˜ì—… (ê¸°ë³¸)</button>
                                    <button onClick={()=>setInputMode('design')} className={`flex-1 py-2 text-xs font-bold rounded ${inputMode==='design'?'bg-white shadow text-blue-600':'text-gray-500'}`}>ì„¤ê³„ (ìƒì„¸)</button>
                                </div>
                            </div>

                            <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-2 flex items-center gap-2 text-sm"><Settings size={16}/> ìì¬ ì„¤ì •</h3>
                                <div className="mb-3 border-b pb-3">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" className="w-4 h-4 text-blue-600" checked={isUserStockMode} onChange={e => setIsUserStockMode(e.target.checked)} />
                                        <span className="text-sm font-bold text-gray-800">ì œí•œëœ ìì¬ë¡œë§Œ ê³„ì‚° (Inventory)</span>
                                    </label>
                                    <p className="text-[10px] text-gray-400 mt-1 pl-6">ì²´í¬ ì‹œ, ì•„ë˜ ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ìì¬ë¡œë§Œ CPë¥¼ ì§­ë‹ˆë‹¤.</p>
                                </div>

                                {isUserStockMode ? (
                                    <div className="space-y-3">
                                        {/* Standard Input Form */}
                                        <div className="bg-blue-50 p-2 rounded border border-blue-100">
                                            <div className="text-xs font-bold text-blue-700 mb-1">í‘œì¤€ ìì¬ ì¶”ê°€</div>
                                            <div className="flex gap-1 mb-1">
                                                <select className="flex-1 p-1 border rounded text-xs" value={`${newStd.w}*${newStd.h}|${newStd.t}`} onChange={e=>{
                                                    const val = e.target.value; if(!val) return;
                                                    const [dim, t] = val.split('|'); const parts = dim.replace('x','*').split('*');
                                                    setNewStd({...newStd, w:parts[0], h:parts[1], t:t, length: getStandardLengthsForInput(parts[0],parts[1],t)[0] });
                                                }}>
                                                    {getSpecOptions().map(opt => <option key={opt.value} value={opt.value.replace('x','*')}>{opt.label}</option>)}
                                                </select>
                                                <select className="w-20 p-1 border rounded text-xs" value={newStd.length} onChange={e=>setNewStd({...newStd, length:+e.target.value})}>
                                                    {getStandardLengthsForInput(newStd.w, newStd.h, newStd.t).map(l => <option key={l} value={l}>{l}</option>)}
                                                </select>
                                            </div>
                                            <div className="flex gap-1">
                                                <input type="number" className="flex-1 p-1 border rounded text-xs" placeholder="ìˆ˜ëŸ‰" value={newStd.qty} onChange={e=>setNewStd({...newStd, qty:+e.target.value})} />
                                                <button onClick={()=>handleAddUserStock('std')} className="px-2 bg-blue-600 text-white rounded text-xs font-bold">+</button>
                                            </div>
                                        </div>
                                        
                                        {/* Remnant Input Form */}
                                        <div className="bg-gray-50 p-2 rounded border border-gray-200">
                                            <div className="text-xs font-bold text-gray-700 mb-1">ì”ì¬/ê¸°íƒ€ ìì¬ ì¶”ê°€</div>
                                            <div className="flex gap-1 mb-1">
                                                <select className="w-full p-1 border rounded text-xs" value={`${newRem.w}*${newRem.h}|${newRem.t}`} onChange={e=>{
                                                    const val = e.target.value; if(!val) return;
                                                    const [dim, t] = val.split('|'); const parts = dim.replace('x','*').split('*');
                                                    setNewRem({...newRem, w:parts[0], h:parts[1], t:t });
                                                }}>
                                                    {getSpecOptions().map(opt => <option key={opt.value} value={opt.value.replace('x','*')}>{opt.label}</option>)}
                                                </select>
                                            </div>
                                            <div className="flex gap-1">
                                                <input type="number" className="flex-1 p-1 border rounded text-xs" placeholder="ê¸¸ì´" value={newRem.length || ''} onChange={e=>setNewRem({...newRem, length:+e.target.value})} />
                                                <input type="number" className="w-12 p-1 border rounded text-xs" placeholder="ìˆ˜ëŸ‰" value={newRem.qty} onChange={e=>setNewRem({...newRem, qty:+e.target.value})} />
                                                <button onClick={()=>handleAddUserStock('rem')} className="px-2 bg-gray-600 text-white rounded text-xs font-bold">+</button>
                                            </div>
                                        </div>

                                        {/* List */}
                                        <div className="max-h-40 overflow-y-auto border-t pt-2 space-y-1">
                                            {userStockList.length === 0 && <p className="text-xs text-gray-400 text-center">ì¶”ê°€ëœ ìì¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>}
                                            {userStockList.map(item => (
                                                <div key={item.id} className="flex justify-between items-center text-xs bg-white p-1 rounded border">
                                                    <span>{item.type==='std'?'ğŸŸ¦':'â¬œ'} {item.w}*{item.h} {item.t}T - <b>{item.length}</b> ({item.qty}ë³¸)</span>
                                                    <button onClick={()=>setUserStockList(userStockList.filter(x=>x.id!==item.id))} className="text-red-500"><Trash2 size={12}/></button>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                ) : (
                                    <div className="space-y-3">
                                        <div>
                                            <label className="text-xs font-bold text-gray-500">ê¸°ë³¸ ê·œê²©</label>
                                            <div className="flex gap-2 mt-1">
                                                <select value={data.spec} onChange={e=>updateCurrentData({spec:e.target.value})} className="flex-1 p-1.5 border rounded text-sm bg-gray-50">
                                                    <option>100*100</option><option>75*75</option><option>100*50</option><option>50*50</option>
                                                </select>
                                                <select value={data.thickness} onChange={e=>updateCurrentData({thickness:e.target.value})} className="w-20 p-1.5 border rounded text-sm bg-gray-50">
                                                    <option>2.1</option><option>2.3</option><option>3.0</option><option>3.2</option>
                                                </select>
                                            </div>
                                        </div>
                                        <div className="pt-2 border-t">
                                            <div className="flex bg-gray-100 p-1 rounded-lg mb-2">
                                                <button onClick={()=>setActiveTab('standard')} className={`flex-1 py-1 text-xs font-bold rounded ${activeTab==='standard'?'bg-white shadow text-blue-600':'text-gray-500'}`}>í‘œì¤€</button>
                                                <button onClick={()=>setActiveTab('custom')} className={`flex-1 py-1 text-xs font-bold rounded ${activeTab==='custom'?'bg-white shadow text-blue-600':'text-gray-500'}`}>ì”ì¬(ê³µí†µ)</button>
                                            </div>
                                            {activeTab === 'custom' && (
                                                <div className="space-y-2">
                                                    {customStocks.map((s, i) => (
                                                        <div key={i} className="flex flex-col gap-1 p-2 bg-gray-50 rounded border">
                                                            <div className="flex gap-1 mb-1">
                                                                <select className="w-full p-1 border rounded text-xs bg-white" value={`${s.w}*${s.h}|${s.t}`} onChange={e => {
                                                                    const val = e.target.value;
                                                                    if(val && val.includes('|')) {
                                                                        const [dim, t] = val.split('|');
                                                                        const parts = dim.replace('x','*').split('*');
                                                                        const n = [...customStocks];
                                                                        n[i].w = parts[0]; n[i].h = parts[1]; n[i].t = t;
                                                                        setCustomStocks(n);
                                                                    }
                                                                }}>
                                                                    <option value="">ê·œê²© ì„ íƒ</option>
                                                                    {getSpecOptions().map(opt => <option key={opt.value} value={opt.value.replace('x','*')}>{opt.label}</option>)}
                                                                </select>
                                                            </div>
                                                            <div className="flex gap-1 items-center">
                                                                <input type="number" className="flex-1 p-1 border rounded text-xs" value={s.length} onChange={e=>{const n=[...customStocks];n[i].length=+e.target.value;setCustomStocks(n)}} placeholder="Length"/>
                                                                <input type="number" className="w-10 p-1 border rounded text-xs" value={s.qty} onChange={e=>{const n=[...customStocks];n[i].qty=+e.target.value;setCustomStocks(n)}} placeholder="Qty"/>
                                                                <button onClick={()=>setCustomStocks(customStocks.filter((_,idx)=>idx!==i))} className="text-red-400"><Trash2 size={14}/></button>
                                                            </div>
                                                        </div>
                                                    ))}
                                                    <button onClick={()=>setCustomStocks([...customStocks,{w:'100',h:'100',t:'2.1',length:0,qty:1}])} className="w-full py-1 text-xs border border-dashed rounded text-blue-500 font-bold hover:bg-blue-50">+ ì¶”ê°€</button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                            <div className="p-3 bg-blue-50 rounded-lg text-xs text-blue-700">ğŸ’¡ <b>[ì‘ì—… í¸ì˜]</b> ëª¨ë“œëŠ” ì”ì¬ 150mm ë¯¸ë§Œ(0 í¬í•¨) ë¶ˆê°€, 650mm ì´ˆê³¼ ê¸°í”¼, ë§ˆí‚¹ ë­‰ì¹˜ê¸°ë¥¼ ìµœìš°ì„ ìœ¼ë¡œ í•©ë‹ˆë‹¤.</div>
                        </div>

                        <div className="lg:col-span-3 bg-white p-0 rounded-xl shadow-sm border border-gray-200 flex flex-col h-[700px] overflow-hidden">
                            <div className="p-3 border-b bg-gray-50 flex justify-between items-center">
                                <span className="text-sm font-bold text-gray-600">ì—‘ì…€ ë¶™ì—¬ë„£ê¸° ì˜ì—­ (ìˆ˜ì • ê°€ëŠ¥)</span>
                                <button onClick={()=>{updateCurrentData({rawInput:'', gridData:[]})}} className="text-xs text-red-500 hover:underline">ì´ˆê¸°í™”</button>
                            </div>
                            <div className="flex-1 overflow-auto custom-scrollbar relative bg-white">
                                {data.gridData.length === 0 ? (
                                    <div className="absolute inset-0 flex items-center justify-center">
                                        <textarea className="absolute inset-0 opacity-0 cursor-text" onPaste={handlePaste} autoFocus />
                                        <div className="text-center text-gray-400 pointer-events-none">
                                            <p className="text-2xl font-bold mb-2">Ctrl + V</p>
                                            <p className="text-sm">ì—‘ì…€ í‘œë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”</p>
                                        </div>
                                    </div>
                                ) : (
                                    <table className="w-full text-xs border-collapse">
                                        <thead className="sticky top-0 bg-white shadow-sm z-10">
                                            <tr>
                                                <th className="p-1 border bg-gray-100 w-8 text-center text-gray-500">#</th>
                                                {data.gridData[0]?.map((_, cIdx) => (
                                                    <th key={cIdx} className="p-1 border min-w-[80px]">
                                                        <select className={`w-full p-1 border rounded text-xs font-bold ${['length','qty'].includes(data.colMapping[cIdx])?'bg-blue-100 text-blue-700':['width','height','thickness'].includes(data.colMapping[cIdx])?'bg-green-100 text-green-700':'bg-white text-gray-400'}`} value={data.colMapping[cIdx] || ''} onChange={e => updateCurrentData({ colMapping: { ...data.colMapping, [cIdx]: e.target.value } })}>
                                                            <option value="">- ë¬´ì‹œ -</option><option value="width">ê°€ë¡œ</option><option value="height">ì„¸ë¡œ</option><option value="thickness">ë‘ê»˜</option><option value="length">ğŸ“ ê¸¸ì´</option><option value="qty">ğŸ”¢ ìˆ˜ëŸ‰</option><option value="marking">ğŸ·ï¸ ë§ˆí‚¹</option>
                                                        </select>
                                                    </th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody className="bg-white">
                                            {data.gridData.map((row, rIdx) => (
                                                <tr key={rIdx} className="hover:bg-blue-50">
                                                    <td className="p-1 border text-center text-gray-400 bg-gray-50">{rIdx + 1}</td>
                                                    {row.map((cell, cIdx) => (
                                                        <td key={cIdx} className="border p-0">
                                                            <input 
                                                                className="w-full h-full p-1 text-xs border-none focus:ring-2 focus:ring-blue-500 outline-none" 
                                                                value={cell} 
                                                                onChange={(e) => handleCellChange(rIdx, cIdx, e.target.value)}
                                                            />
                                                        </td>
                                                    ))}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Result View ---
        const ResultView = ({ currentDong, dongs, setCurrentDong, addDong, deleteDong, renameDong, resultsByDong, runAllDongs, openExcelModal, saveToFirebase }) => {
            const [resultTab, setResultTab] = useState('min_rows'); 
            const allResults = resultsByDong && currentDong ? resultsByDong[currentDong] : null;
            const results = allResults ? allResults[resultTab] : null;
            const specKeys = results ? Object.keys(results).sort() : [];
            let overallSeq = 1;

            return (
                <div className="animate-fade-in pb-20">
                    <div className="flex justify-between items-center mb-4 print:hidden">
                        <h2 className="text-lg font-bold text-gray-800">CP ê²°ê³¼ í™•ì¸ ({currentDong})</h2>
                        <div className="flex gap-2">
                            <button onClick={runAllDongs} className="bg-gray-800 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-gray-900 transition flex items-center gap-2"><Layers size={16}/> ì „ì²´ ë™ ê³„ì‚°</button>
                            <button onClick={openExcelModal} className="bg-green-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-green-700 flex items-center gap-2 transition"><FileDown size={16}/> ì—‘ì…€ ì €ì¥</button>
                            <button onClick={saveToFirebase} className="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-blue-700 flex items-center gap-2 transition"><Save size={16}/> ì €ì¥</button>
                        </div>
                    </div>
                    <DongTabs dongs={dongs} currentDong={currentDong} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} />

                    {(!allResults || !results) ? (
                        <div className="text-center py-20 bg-white rounded-xl border border-dashed border-gray-300 text-gray-400"><p>ê³„ì‚°ëœ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</p></div>
                    ) : (
                        <div>
                            <div className="flex mb-4 border-b print:hidden">
                                <button onClick={()=>setResultTab('min_rows')} className={`px-6 py-3 font-bold text-sm ${resultTab==='min_rows' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-500 hover:text-gray-700'}`}>â‘  ì‘ì—… í¸ì˜ (Work Convenience)</button>
                                <button onClick={()=>setResultTab('min_loss')} className={`px-6 py-3 font-bold text-sm ${resultTab==='min_loss' ? 'border-b-2 border-green-600 text-green-600' : 'text-gray-500 hover:text-gray-700'}`}>â‘¡ LOSS ìµœì†Œí™” (ìì¬ ì ˆì•½)</button>
                            </div>
                            <div className="space-y-8 bg-white p-8 rounded-xl shadow-sm border border-gray-200 min-h-screen">
                                {specKeys.map((specKey, idx) => {
                                    const { plan, summary } = results[specKey];
                                    let w="?", h="?", t="?";
                                    try {
                                        const dims = specKey.split(' ')[0] || "";
                                        const tPart = specKey.split(' ')[1] || "";
                                        if (dims.includes('*')) [w, h] = dims.split('*'); else if (dims.includes('x')) [w, h] = dims.split('x'); else { w=dims; h=""; }
                                        t = tPart.replace('T', '');
                                    } catch(e) {}
                                    const displayLoss = summary.totalLoss.toLocaleString();
                                    
                                    let sortedPlan = [...plan];
                                    // *** PATCH: Sort by Stock Length Descending ***
                                    sortedPlan.sort((a, b) => {
                                        if (b.stockLength !== a.stockLength) return b.stockLength - a.stockLength;
                                        if (resultTab === 'min_rows') return b.qty - a.qty;
                                        return a.remainder - b.remainder;
                                    });

                                    return (
                                        <div key={specKey || idx} className="break-before-page">
                                            <div className="flex items-center gap-3 mb-3 pb-2 border-b border-gray-100 print:border-none">
                                                <span className={`font-bold px-3 py-1 rounded text-sm print:hidden ${resultTab==='min_rows'?'bg-blue-100 text-blue-700':'bg-green-100 text-green-700'}`}>#{idx+1} {resultTab==='min_rows'?'ì‘ì—…í¸ì˜':'LOSSìµœì†Œ'}</span>
                                                <h3 className="font-bold text-xl text-gray-800">{specKey}</h3>
                                                <div className="text-xs text-gray-500 ml-auto flex gap-4 print:text-black">
                                                    <span>ì´ ì›ë³¸: <b>{summary.totalBars}ë³¸</b></span>
                                                    <span>ì´ ì”ì¬: <b>{displayLoss}mm</b></span>
                                                    <span>ì”ì¬ìœ¨: {summary.lossRate}%</span>
                                                </div>
                                            </div>
                                            <table className="w-full border-collapse text-center text-xs">
                                                <thead>
                                                    <tr className="bg-gray-100 text-gray-700 h-8 border-y border-gray-300 print:bg-gray-200">
                                                        <th className="border-x border-gray-200 w-10">ìˆœë²ˆ</th>
                                                        <th className="border-x border-gray-200 w-12">ë‘ê»˜</th>
                                                        <th className="border-x border-gray-200 w-12">ì¥ë³€</th>
                                                        <th className="border-x border-gray-200 w-12">ë‹¨ë³€</th>
                                                        <th className="border-x border-gray-200 w-16">ì›ë³¸ê¸¸ì´</th>
                                                        <th className="border-x border-gray-200 w-12">ìˆ˜ëŸ‰</th>
                                                        <th className="border-x border-gray-200 w-16 bg-white font-bold text-blue-600 border-2 border-blue-100 print:border">ì»·íŒ…ê¸¸ì´</th>
                                                        <th className="border-x border-gray-200 w-12">ì»·íŒ…ìˆ˜</th>
                                                        <th className="border-x border-gray-200 w-12">ìˆ˜ëŸ‰</th>
                                                        <th className="border-x border-gray-200">ë§ˆí‚¹</th>
                                                        <th className="border-x border-gray-200 w-16">ë³¸ë‹¹LOSS</th>
                                                        <th className="border-x border-gray-200 w-20">ì´LOSS</th>
                                                        <th className="border-x border-gray-200 w-12">ë¹„ê³ </th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {sortedPlan.map((group, gIdx) => {
                                                        const rowClass = group.remainder < 150 ? 'bg-red-50 text-red-900' : 'bg-white';
                                                        return group.parts.map((part, pIdx) => (
                                                            <tr key={`${gIdx}-${pIdx}`} className={`${rowClass} border-b border-gray-200 hover:bg-gray-50 transition print:bg-transparent`}>
                                                                {pIdx===0 && (
                                                                    <>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200 font-bold bg-gray-50 print:bg-transparent">{overallSeq++}</td>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200">{t}</td>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200">{w}</td>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200">{h}</td>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200 font-bold">{group.stockLength}</td>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200">{Math.floor(group.qty)}</td>
                                                                    </>
                                                                )}
                                                                <td className="border-x border-gray-200 font-bold text-gray-800">{part.length}</td>
                                                                <td className="border-x border-gray-200">{part.count}</td>
                                                                <td className="border-x border-gray-200 font-bold">{Math.floor(part.totalQty)}</td>
                                                                <td className="border-x border-gray-200 text-left px-2 truncate max-w-[150px]">{part.marking}</td>
                                                                {pIdx===0 && (
                                                                    <>
                                                                        <td rowSpan={group.parts.length} className={`border-x border-gray-200 font-bold ${group.remainder >= 650 ? 'bg-[#FFCCBC] text-red-600' : (group.remainder < 150 ? 'text-red-600' : '')}`}>{group.remainder.toLocaleString()}</td>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200 text-gray-500">{(group.remainder * group.qty).toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                                                                        <td rowSpan={group.parts.length} className="border-x border-gray-200"></td>
                                                                    </>
                                                                )}
                                                            </tr>
                                                        ));
                                                    })}
                                                </tbody>
                                            </table>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- Excel Export Modal Component ---
        const ExcelExportModal = ({ isOpen, onClose, onConfirm, dongs }) => {
            const [targetType, setTargetType] = useState('current');
            const [modeType, setModeType] = useState('min_rows');

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 print:hidden">
                    <div className="bg-white rounded-xl shadow-2xl p-6 w-96 modal-fade-in relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600"><X size={20}/></button>
                        <h3 className="text-xl font-bold text-gray-800 mb-6 flex items-center gap-2"><FileDown className="text-green-600"/> ì—‘ì…€ ë‹¤ìš´ë¡œë“œ</h3>
                        <div className="space-y-6">
                            <div>
                                <label className="block text-sm font-bold text-gray-700 mb-2">ì €ì¥ ëŒ€ìƒ</label>
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => setTargetType('current')} className={`p-3 rounded-lg border text-sm font-bold flex items-center justify-center gap-2 transition ${targetType === 'current' ? 'border-green-500 bg-green-50 text-green-700' : 'border-gray-200 hover:bg-gray-50'}`}>í˜„ì¬ ë™ë§Œ</button>
                                    <button onClick={() => setTargetType('all')} className={`p-3 rounded-lg border text-sm font-bold flex items-center justify-center gap-2 transition ${targetType === 'all' ? 'border-green-500 bg-green-50 text-green-700' : 'border-gray-200 hover:bg-gray-50'}`}>ì „ì²´ ë™</button>
                                </div>
                            </div>
                            <div>
                                <label className="block text-sm font-bold text-gray-700 mb-2">ì €ì¥ ë²„ì „</label>
                                <div className="space-y-2">
                                    <button onClick={() => setModeType('min_rows')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'min_rows' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                        <span>â‘  ì‘ì—… í¸ì˜ (Work Convenience)</span>{modeType === 'min_rows' && <Check size={16}/>}
                                    </button>
                                    <button onClick={() => setModeType('min_loss')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'min_loss' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                        <span>â‘¡ LOSS ìµœì†Œí™” (ìì¬ ì ˆì•½)</span>{modeType === 'min_loss' && <Check size={16}/>}
                                    </button>
                                    <button onClick={() => setModeType('both')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'both' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                        <span>â‘¢ ë‘˜ ë‹¤ ì €ì¥ (íŒŒì¼ 2ê°œ)</span>{modeType === 'both' && <Check size={16}/>}
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div className="mt-8">
                            <button onClick={() => onConfirm(targetType, modeType)} className="w-full bg-green-600 text-white py-3 rounded-xl font-bold shadow-lg hover:bg-green-700 transition flex justify-center items-center gap-2"><FileDown size={18}/> ë‹¤ìš´ë¡œë“œ ì‹œì‘</button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Main App ---
        function App() {
            // ... (State logic same as before)
            const [user, setUser] = useState(null);
            const [viewMode, setViewMode] = useState('input'); 
            const [isFirebaseReady, setIsFirebaseReady] = useState(false);
            const [isExcelModalOpen, setIsExcelModalOpen] = useState(false);
            const [projectInfo, setProjectInfo] = useState({ company: '', site: '', note: '', isIronBanding: false, isUnder1Ton: false });
            const [dongs, setDongs] = useState(['1ë™']);
            const [currentDong, setCurrentDong] = useState('1ë™');
            const globalSettings = STANDARD_STOCKS;
            const [dongData, setDongData] = useState({ '1ë™': { rawInput: '', gridData: [], colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' }, parsedItems: [], spec: '100*100', thickness: '2.1' } });
            const [resultsByDong, setResultsByDong] = useState({});
            const [activeTab, setActiveTab] = useState('standard'); 
            const [customStocks, setCustomStocks] = useState([{ w:'100', h:'100', t:'2.1', length: 6000, qty: 10 }]);
            const [savedPlans, setSavedPlans] = useState([]);
            const [isUserStockMode, setIsUserStockMode] = useState(false);
            const [userStockList, setUserStockList] = useState([]);
            const firebaseRef = useRef(null);
            const dbRef = useRef(null);

            // ... (Data Functions)
            const getCurrentData = () => dongData[currentDong] || { rawInput: '', gridData: [], colMapping: {}, parsedItems: [], spec: '100*100', thickness: '2.1' };
            const updateCurrentData = (updates) => { setDongData(prev => ({ ...prev, [currentDong]: { ...prev[currentDong], ...updates } })); };
            const getStockLengths = (w, h, t) => {
                const dims = [parseInt(w), parseInt(h)].sort((a,b)=>b-a);
                const specKey = `${dims[0]}x${dims[1]}`;
                const thickStr = String(t).trim();
                const settings = globalSettings;
                if (settings[specKey]) {
                    if (settings[specKey][thickStr]) return settings[specKey][thickStr];
                    if (thickStr === '2.3' && settings[specKey]['2.1']) return settings[specKey]['2.1']; 
                    if (settings[specKey]['all']) return settings[specKey]['all'];
                }
                return settings["default"] || [];
            };
            // ... (Firebase Init)
            const initFirebase = async () => { if (!window.FirebaseSDK) return; try { const { initializeApp, getAuth, getFirestore, signInAnonymously, onAuthStateChanged, signInWithCustomToken } = window.FirebaseSDK; const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null; if (!firebaseConfig) return; if (!firebaseRef.current) { const app = initializeApp(firebaseConfig); const auth = getAuth(app); const db = getFirestore(app); firebaseRef.current = app; dbRef.current = db; try { if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) await signInWithCustomToken(auth, __initial_auth_token); else await signInAnonymously(auth); } catch (e) { console.error("Auth Error", e); } onAuthStateChanged(auth, async (u) => { setUser(u); setIsFirebaseReady(true); }); } } catch (e) { console.warn(e); } };
            useEffect(() => { if (window.FirebaseSDK) initFirebase(); else window.addEventListener('firebase-sdk-ready', initFirebase); return () => window.removeEventListener('firebase-sdk-ready', initFirebase); }, []);
            useEffect(() => { if (!user || !dbRef.current || !isFirebaseReady) return; try { const { collection, query, onSnapshot } = window.FirebaseSDK; const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; const q = query(collection(dbRef.current, 'artifacts', appId, 'public', 'data', 'cuttingPlans')); const unsubscribe = onSnapshot(q, (snapshot) => { const plans = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); plans.sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0)); setSavedPlans(plans); }); return () => unsubscribe(); } catch(e) {} }, [user, isFirebaseReady]);
            // ... (Action Handlers)
            const addDong = () => { const newDongName = prompt("ìƒˆ ë™ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:"); if (newDongName && !dongs.includes(newDongName)) { setDongs([...dongs, newDongName]); setDongData(prev => ({ ...prev, [newDongName]: { rawInput: '', gridData: [], colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' }, parsedItems: [], spec: '100*100', thickness: '2.1' } })); setCurrentDong(newDongName); } };
            const renameDong = (oldName) => { const newName = prompt(`'${oldName}'ì˜ ìƒˆ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:`, oldName); if (newName && newName !== oldName && !dongs.includes(newName)) { setDongs(prev => prev.map(d => d === oldName ? newName : d)); if (currentDong === oldName) setCurrentDong(newName); setDongData(prev => { const n = {...prev}; n[newName] = n[oldName]; delete n[oldName]; return n; }); setResultsByDong(prev => { const n = {...prev}; if(n[oldName]) { n[newName] = n[oldName]; delete n[oldName]; } return n; }); } };
            const deleteDong = (targetDong) => { if (dongs.length <= 1) { alert("ìµœì†Œ í•˜ë‚˜ì˜ ë™ì€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."); return; } if (confirm(`'${targetDong}'ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) { const newDongs = dongs.filter(d => d !== targetDong); setDongs(newDongs); if (currentDong === targetDong) setCurrentDong(newDongs[0]); setDongData(prev => { const n = {...prev}; delete n[targetDong]; return n; }); setResultsByDong(prev => { const n = {...prev}; delete n[targetDong]; return n; }); } };
            const handlePaste = (e) => { e.preventDefault(); const text = e.clipboardData.getData('text'); const rows = text.trim().split('\n').map(row => row.split('\t')); updateCurrentData({ rawInput: text, gridData: rows }); };
            const parseItemsFromGrid = (gridData, colMapping, defaultSpec, defaultThickness) => { const lenIdx = Object.keys(colMapping).find(key => colMapping[key] === 'length'); const qtyIdx = Object.keys(colMapping).find(key => colMapping[key] === 'qty'); if (!lenIdx || !qtyIdx) return []; const wIdx = Object.keys(colMapping).find(key => colMapping[key] === 'width'); const hIdx = Object.keys(colMapping).find(key => colMapping[key] === 'height'); const tIdx = Object.keys(colMapping).find(key => colMapping[key] === 'thickness'); const markIdx = Object.keys(colMapping).find(key => colMapping[key] === 'marking'); let items = []; let rowCounter = 0; gridData.forEach((row) => { let rawLen = row[lenIdx]?.trim().replace(/,/g, ''); let rawQty = row[qtyIdx]?.trim().replace(/,/g, ''); if (!rawLen || !rawQty) return; let length = parseFloat(rawLen); const qty = parseInt(rawQty, 10); if (isNaN(length) || isNaN(qty) || qty <= 0) return; if (length < 20) length = Math.round(length * 1000); else length = Math.round(length); let w = wIdx ? row[wIdx]?.trim().replace(/[^0-9.]/g, '') : ''; let h = hIdx ? row[hIdx]?.trim().replace(/[^0-9.]/g, '') : ''; let t = tIdx ? row[tIdx]?.trim().replace(/[^0-9.]/g, '') : ''; let marking = markIdx ? (row[markIdx]?.trim() || '') : ''; if (!w) w = defaultSpec.split('*')[0] || '100'; if (!h) h = defaultSpec.split('*')[1] || '100'; if (!t) t = defaultThickness; const dims = [parseInt(w), parseInt(h)].sort((a,b)=>b-a); const specKey = `${dims[0]}*${dims[1]} ${t}T`; items.push({ id: rowCounter++, length, qty, marking, specKey, w: dims[0], h: dims[1], t: t }); }); return items; };

            const solvePatternBased = (items, availableStocks, mode, strategy = 'mixed', randomize = false, stockLimits = {}) => {
                let inventory = {}; items.forEach(item => { if (!inventory[item.length]) { inventory[item.length] = { count: 0, itemsByMarking: {} }; } inventory[item.length].count++; if (!inventory[item.length].itemsByMarking[item.marking]) { inventory[item.length].itemsByMarking[item.marking] = []; } inventory[item.length].itemsByMarking[item.marking].push(item); });
                let uniqueLengths = Object.keys(inventory).map(Number).sort((a,b) => b - a);
                if (randomize) { for (let i = uniqueLengths.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [uniqueLengths[i], uniqueLengths[j]] = [uniqueLengths[j], uniqueLengths[i]]; } }
                let finalPlan = []; let unallocated = []; let currentStockLimits = { ...stockLimits };
                availableStocks.sort((a, b) => a - b);
                
                while (uniqueLengths.length > 0) {
                    uniqueLengths = uniqueLengths.filter(len => inventory[len].count > 0);
                    if (uniqueLengths.length === 0) break;
                    let bestPattern = null; let bestScore = -Infinity; let candidateStocks = [...availableStocks];
                    
                    for (let stockLen of candidateStocks) {
                        if (currentStockLimits[stockLen] !== undefined && currentStockLimits[stockLen] <= 0) continue;
                        let strategyBonus = 0; if (strategy !== 'mixed' && parseInt(strategy.split('_')[1]) === stockLen) strategyBonus = 20000;
                        
                        let startingCandidates = [...uniqueLengths];
                        if (randomize) { for (let i = startingCandidates.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [startingCandidates[i], startingCandidates[j]] = [startingCandidates[j], startingCandidates[i]]; } }

                        for (let startLen of startingCandidates) {
                            if (startLen > stockLen) continue;
                            let currentPattern = { parts: [], remainder: stockLen }; let tempInventoryCount = {};
                            currentPattern.parts.push(startLen); currentPattern.remainder -= startLen; tempInventoryCount[startLen] = (tempInventoryCount[startLen] || 0) + 1;
                            
                            let candidates = [...uniqueLengths];
                            
                            while (currentPattern.remainder > 0) {
                                let found = false;
                                for (let l of candidates) {
                                    const usedCountInPattern = (tempInventoryCount[l] || 0); if (inventory[l].count <= usedCountInPattern) continue;
                                    if (l <= currentPattern.remainder) {
                                        let nextRem = currentPattern.remainder - l;
                                        if (nextRem === 0 || nextRem >= 150) { 
                                            currentPattern.parts.push(l); currentPattern.remainder -= l; tempInventoryCount[l] = (tempInventoryCount[l] || 0) + 1; found = true; break; 
                                        }
                                    }
                                }
                                if (!found) break;
                            }
                            
                            if (currentPattern.remainder > 0 && currentPattern.remainder < 150) continue;
                            
                            // *** SCORING SYSTEM (Ver 10.1.0) ***
                            let score = 0; // Base Score

                            // 1. ìˆœë²ˆ ìµœì†Œí™” (Maximize Repeats)
                            let maxRepeats = Infinity; 
                            Object.keys(tempInventoryCount).forEach(p => { 
                                maxRepeats = Math.min(maxRepeats, Math.floor(inventory[p].count / tempInventoryCount[p])); 
                            });
                            if (currentStockLimits[stockLen] !== undefined) maxRepeats = Math.min(maxRepeats, currentStockLimits[stockLen]);
                            
                            // Strategy Bonus
                            score += strategyBonus;

                            if (mode === 'min_rows') {
                                score += (maxRepeats * 5000); 

                                const markingsInPattern = new Set();
                                Object.keys(tempInventoryCount).forEach(len => {
                                    const inv = inventory[len];
                                    let domMarking = ''; let maxC = -1;
                                    Object.keys(inv.itemsByMarking).forEach(m => {
                                        if(inv.itemsByMarking[m].length > maxC) { maxC = inv.itemsByMarking[m].length; domMarking = m; }
                                    });
                                    if(domMarking) markingsInPattern.add(domMarking);
                                });
                                if (markingsInPattern.size > 1) score -= 10000; 
                                
                                score -= currentPattern.remainder; 

                                if (currentPattern.remainder > 650) score -= 100000; 

                                if (currentPattern.parts.length > 8) score -= ((currentPattern.parts.length - 8) * 3000);

                                const shortParts = currentPattern.parts.filter(p => p <= 500).length;
                                if (shortParts > 4) score -= ((shortParts - 4) * 2000);

                                score -= (stockLen * 2);
                            } 
                            else { 
                                // Min Loss Mode
                                if (currentPattern.remainder === 0) score += 1000000; 
                                else score -= currentPattern.remainder; 
                            }
                            
                            if (score > bestScore) { bestScore = score; bestPattern = { ...currentPattern, maxRepeats, tempInventoryCount, stockLength: stockLen }; } 
                        }
                    }
                    
                    if (bestPattern) {
                        const repeat = bestPattern.maxRepeats; 
                        if (currentStockLimits[bestPattern.stockLength] !== undefined) currentStockLimits[bestPattern.stockLength] -= repeat;
                        
                        for (let r = 0; r < repeat; r++) {
                            const allocatedParts = [];
                            let stickyMarking = null;

                            bestPattern.parts.forEach(len => {
                                const group = inventory[len]; 
                                const markings = Object.keys(group.itemsByMarking).filter(m => group.itemsByMarking[m].length > 0); 
                                
                                markings.sort((a, b) => {
                                    if (stickyMarking) {
                                        if (a === stickyMarking && b !== stickyMarking) return -1;
                                        if (b === stickyMarking && a !== stickyMarking) return 1;
                                    }
                                    return group.itemsByMarking[b].length - group.itemsByMarking[a].length;
                                });

                                if (markings.length > 0) { 
                                    const targetMarking = markings[0]; 
                                    if (!stickyMarking) stickyMarking = targetMarking; // Set sticky
                                    const item = group.itemsByMarking[targetMarking].pop(); 
                                    group.count--; 
                                    allocatedParts.push(item); 
                                }
                            });
                            allocatedParts.sort((a,b)=>b.length-a.length); finalPlan.push({ stockLength: bestPattern.stockLength, parts: allocatedParts, remainder: bestPattern.remainder });
                        }
                    } else { break; }
                }
                // Handle Unallocated (same as before)
                Object.keys(inventory).forEach(len => {
                    const group = inventory[len]; const markings = Object.keys(group.itemsByMarking);
                    markings.forEach(m => {
                        while (group.itemsByMarking[m].length > 0) {
                            const item = group.itemsByMarking[m].pop(); group.count--; let selectedStock = null;
                            for (let sLen of availableStocks) { if (currentStockLimits[sLen] !== undefined && currentStockLimits[sLen] <= 0) continue; if (sLen >= item.length) { const r = sLen - item.length; if (r === 0 || r >= 150) { selectedStock = sLen; break; } } }
                            if (!selectedStock) { for (let sLen of availableStocks) { if (currentStockLimits[sLen] > 0 && sLen >= item.length) { selectedStock = sLen; break; } } }
                            if (!selectedStock && Object.keys(stockLimits).length === 0) selectedStock = Math.max(...availableStocks);
                            if (selectedStock) { if (currentStockLimits[selectedStock] !== undefined) currentStockLimits[selectedStock]--; finalPlan.push({ stockLength: selectedStock, parts: [item], remainder: selectedStock - item.length }); } else { unallocated.push(item); }
                        }
                    });
                });
                return finalPlan;
            };

            const calculatePlanScore = (plan) => {
                let score = 0;
                score -= (plan.length * 10000);

                let markingDistribution = {};
                plan.forEach(pattern => {
                    let markingsInThisPattern = new Set(pattern.parts.map(p => p.marking));
                    markingsInThisPattern.forEach(m => {
                        if (!markingDistribution[m]) markingDistribution[m] = 0;
                        markingDistribution[m]++;
                    });
                    
                    let rem = pattern.remainder;
                    if (rem > 0 && rem < 150) return -Infinity; // Hard Fail
                    if (rem > 650) score -= 100000; // Remnant Split Penalty
                    score -= rem; // Loss Penalty

                    if (pattern.parts.length > 8) score -= ((pattern.parts.length - 8) * 3000);

                    let shortParts = pattern.parts.filter(p => p.length <= 500).length;
                    if (shortParts > 4) score -= ((shortParts - 4) * 2000);
                });

                Object.keys(markingDistribution).forEach(m => {
                    let count = markingDistribution[m];
                    if (count > 1) {
                        score -= ((count - 1) * 50000); 
                    }
                });

                return score;
            };

            const runAdvancedOptimization = (items, mode) => {
                const groups = {}; items.forEach(item => { if(!groups[item.specKey]) groups[item.specKey] = []; groups[item.specKey].push(item); }); const computedResults = {};
                Object.keys(groups).forEach(specKey => {
                    let stockW = '100', stockH = '100', stockT = '2.1';
                    try { const dims = specKey.split(' ')[0] || "100*100"; const thick = specKey.split(' ')[1] || "2.1T"; if (dims.includes('*')) [stockW, stockH] = dims.split('*'); stockT = thick.replace('T', ''); } catch(e) {}
                    const groupItems = groups[specKey]; let allParts = []; groupItems.forEach(item => { for (let i = 0; i < item.qty; i++) allParts.push({ ...item, uuid: Math.random() }); });
                    let availableStocks = []; let stockLimits = {};
                    if (isUserStockMode) {
                        userStockList.forEach(s => { if (parseInt(s.w) == parseInt(stockW) && parseInt(s.h) == parseInt(stockH) && s.t == stockT) { if (!stockLimits[s.length]) stockLimits[s.length] = 0; stockLimits[s.length] += s.qty; availableStocks.push(s.length); } });
                        availableStocks = [...new Set(availableStocks)].sort((a,b)=>a-b);
                    } else {
                        let stds = getStockLengths(stockW, stockH, stockT) || []; if (activeTab === 'custom') { customStocks.forEach(s => { if (parseInt(s.w) == parseInt(stockW) && parseInt(s.h) == parseInt(stockH) && s.t == stockT) { if (!stockLimits[s.length]) stockLimits[s.length] = 0; stockLimits[s.length] += s.qty; availableStocks.push(s.length); } }); }
                        stds.forEach(l => { if (!availableStocks.includes(l)) availableStocks.push(l); }); availableStocks.sort((a,b)=>a-b);
                    }
                    if(availableStocks.length === 0) availableStocks = [6000];
                    
                    const SIMULATION_RUNS = 5000; 
                    const validPlans = [];

                    for (let i = 0; i < SIMULATION_RUNS; i++) {
                        let strategy = 'mixed'; if (Math.random() > 0.5 && availableStocks.length > 0) { const randomStock = availableStocks[Math.floor(Math.random() * availableStocks.length)]; strategy = `force_${randomStock}`; }
                        const plan = solvePatternBased([...allParts], availableStocks, mode, strategy, true, stockLimits);
                        
                        let totalLoss = 0; let invalidCount = 0; const patternSignature = new Set();
                        plan.forEach(p => { totalLoss += p.remainder; if (p.remainder < 150 && p.remainder !== 0) invalidCount++; if (p.remainder === 0) invalidCount++; const sig = `${p.stockLength}:${p.parts.map(x=>x.length).sort().join(',')}`; patternSignature.add(sig); });
                        
                        if (invalidCount === 0) {
                            let planScore = 0;
                            if (mode === 'min_rows') {
                                planScore = calculatePlanScore(plan);
                            } else {
                                planScore = -totalLoss;
                            }
                            validPlans.push({ plan, score: planScore, totalLoss, rowCount: patternSignature.size });
                        }
                    }

                    if (validPlans.length > 0) {
                        validPlans.sort((a, b) => b.score - a.score);
                    }
                    
                    const bestGlobalPlan = validPlans.length > 0 ? validPlans[0].plan : [];

                    const groupedMap = new Map();
                    bestGlobalPlan.forEach(plan => {
                        const sortedParts = [...plan.parts].sort((a,b) => b.length - a.length || a.marking.localeCompare(b.marking));
                        const signature = sortedParts.map(p => `${p.length}[${p.marking}]`).join('|');
                        const key = `${plan.stockLength}_${signature}`;
                        if (groupedMap.has(key)) { const existing = groupedMap.get(key); existing.qty += 1; } 
                        else {
                            const partCounts = new Map(); sortedParts.forEach(p => { const pKey = `${p.length}__${p.marking}`; if(partCounts.has(pKey)) { partCounts.get(pKey).count++; } else { partCounts.set(pKey, { ...p, count: 1 }); } });
                            const displayParts = Array.from(partCounts.values()).sort((a,b)=>b.length-a.length);
                            groupedMap.set(key, { id: key, stockLength: plan.stockLength, parts: displayParts, totalPartsInOneStock: plan.parts.length, remainder: plan.remainder, qty: 1 });
                        }
                    });
                    groupedMap.forEach(group => { group.parts = group.parts.map(p => ({ ...p, totalQty: p.count * group.qty })); group.parts.sort((a,b) => b.length - a.length || a.marking.localeCompare(b.marking)); });
                    const finalGroupedPlan = Array.from(groupedMap.values());
                    
                    // *** MODIFICATION: Sort by Stock Length Descending ***
                    finalGroupedPlan.sort((a, b) => {
                        // 1. Primary Sort: Stock Length (Descending) - ê¸´ ì›ë³¸ì´ ë¨¼ì € ì˜¤ë„ë¡
                        if (b.stockLength !== a.stockLength) return b.stockLength - a.stockLength;
                        
                        // 2. Secondary Sort: Based on Mode
                        if (mode === 'min_rows') return b.qty - a.qty; // Then Quantity Descending
                        else return a.remainder - b.remainder; // Then Remainder Ascending
                    });
                    
                    const totalBars = bestGlobalPlan.length; const totalStockLen = bestGlobalPlan.reduce((acc, p) => acc + p.stockLength, 0); const totalPartLen = bestGlobalPlan.reduce((acc, p) => acc + p.parts.reduce((s, pt) => s + pt.length, 0), 0); const totalLoss = totalStockLen - totalPartLen; const lossRate = totalStockLen ? ((totalLoss / totalStockLen) * 100).toFixed(2) : 0;
                    computedResults[specKey] = { plan: finalGroupedPlan, summary: { totalBars, lossRate, totalLoss, unallocatedCount: 0 } };
                });
                return computedResults;
            };

            const processGridData = () => { const data = getCurrentData(); const items = parseItemsFromGrid(data.gridData, data.colMapping, data.spec, data.thickness); if (items.length === 0) { alert("ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."); return; } updateCurrentData({ parsedItems: items }); setTimeout(() => { const resMinRows = runAdvancedOptimization(items, 'min_rows'); const resMinLoss = runAdvancedOptimization(items, 'min_loss'); setResultsByDong(prev => ({ ...prev, [currentDong]: { min_rows: resMinRows, min_loss: resMinLoss } })); setViewMode('result'); }, 50); };
            const runAllDongs = () => { setTimeout(() => { const newResults = {}; let processedCount = 0; dongs.forEach(dName => { const dData = dongData[dName]; if (!dData || !dData.gridData || dData.gridData.length === 0) return; const items = parseItemsFromGrid(dData.gridData, dData.colMapping, dData.spec, dData.thickness); if (items.length > 0) { newResults[dName] = { min_rows: runAdvancedOptimization(items, 'min_rows'), min_loss: runAdvancedOptimization(items, 'min_loss') }; processedCount++; } }); if (processedCount > 0) { setResultsByDong(newResults); alert(`ì´ ${processedCount}ê°œ ë™ì˜ ê³„ì‚°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`); setViewMode('result'); } else { alert("ê³„ì‚°í•  ë°ì´í„°ê°€ ìˆëŠ” ë™ì´ ì—†ìŠµë‹ˆë‹¤."); } }, 50); };

            // ... (Export and Helper Functions same as before)
            const handleExcelExport = (targetType, modeType) => { try { if (typeof XLSX === 'undefined') throw new Error("XLSX ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."); if (typeof saveAs === 'undefined') throw new Error("FileSaver ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."); setIsExcelModalOpen(false); const exportTargets = targetType === 'current' ? [currentDong] : dongs; let downloadCount = 0; exportTargets.forEach(dongName => { const modes = modeType === 'both' ? ['min_rows', 'min_loss'] : [modeType]; modes.forEach(mode => { const wb = exportToExcelBuffer(dongName, mode); if (wb) { const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' }); const company = projectInfo.company || 'ì—…ì²´'; const site = projectInfo.site || 'í˜„ì¥'; let fileName = `${company}(${site})-${dongName}`; if (modeType === 'both') { const suffix = mode === 'min_rows' ? 'ì‘ì—…í¸ì˜' : 'LOSSìµœì†Œ'; fileName += `_${suffix}`; } fileName += '.xlsx'; const blob = new Blob([wbout], { type: "application/octet-stream" }); setTimeout(() => { saveAs(blob, fileName); }, downloadCount * 500); downloadCount++; } }); }); if (downloadCount === 0) alert("ì €ì¥í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."); } catch (e) { console.error(e); alert("ì˜¤ë¥˜: " + e.message); } };
            const getUnitWeight = (w, h, t) => { const dims = [parseInt(w), parseInt(h)].sort((a,b)=>b-a); const key = `${dims[0]}-${dims[1]}-${t}`; return UNIT_WEIGHT_DATA[key] || 0; };
            const exportToExcelBuffer = (targetDong, mode) => {
                 const allResults = resultsByDong[targetDong];
                if (!allResults) return null;
                const results = allResults[mode];
                if(!results) return null;
                
                const wb = XLSX.utils.book_new();
                const specKeys = Object.keys(results).sort();
                
                const FONT_NORMAL = { name: "Malgun Gothic", sz: 11 };
                const FONT_BOLD = { name: "Malgun Gothic", sz: 11, bold: true };
                const TITLE_STYLE = { font: { name: "Malgun Gothic", sz: 15, bold: true }, alignment: { horizontal: "left" } };
                const HEADER_STYLE = { fill: { fgColor: { rgb: "CCEEFF" } }, font: FONT_BOLD, alignment: { horizontal: "center", vertical: "center" }, border: { top: {style:"thin"}, bottom: {style:"thin"}, left: {style:"thin"}, right: {style:"thin"} } };
                const CELL_STYLE = { font: FONT_NORMAL, alignment: { horizontal: "center", vertical: "center" }, border: { top: {style:"thin"}, bottom: {style:"thin"}, left: {style:"thin"}, right: {style:"thin"} } };
                const NOTE_STYLE = { fill: { fgColor: { rgb: "FFFF00" } }, font: FONT_BOLD, alignment: { horizontal: "center", vertical: "center" }, border: { top: {style:"thin"}, bottom: {style:"thin"}, left: {style:"thin"}, right: {style:"thin"} } };
                const SUM_STYLE_BLUE = { fill: { fgColor: { rgb: "CCEEFF" } }, font: FONT_BOLD, alignment: { horizontal: "center", vertical: "center" }, border: { top: {style:"thin"}, bottom: {style:"thin"}, left: {style:"thin"}, right: {style:"thin"} } };
                const STYLE_WARNING_LOSS = { fill: { fgColor: { rgb: "FFCCBC" } }, font: { name: "Malgun Gothic", sz: 11, color: { rgb: "FF0000" }, bold: true }, alignment: { horizontal: "center", vertical: "center" }, border: { top: {style:"thin"}, bottom: {style:"thin"}, left: {style:"thin"}, right: {style:"thin"} } };
                const STYLE_OTHER_SPEC = { fill: { fgColor: { rgb: "F5F5F5" } }, font: FONT_NORMAL, alignment: { horizontal: "center", vertical: "center" }, border: { top: {style:"thin"}, bottom: {style:"thin"}, left: {style:"thin"}, right: {style:"thin"} } };

                // 1. CP Sheet (Main)
                const wsData = [];
                // ... (Rows 0~4 setup logic remains same)
                wsData.push([`â€» ${projectInfo.company || 'ì—…ì²´ëª…'}(${projectInfo.site || 'í˜„ì¥ëª…'}) - ${targetDong}`]);
                wsData.push([]);
                const noteParts = []; if (projectInfo.isIronBanding) noteParts.push("ì² ë°´ë”© ë™í‘œê¸°"); if (projectInfo.isUnder1Ton) noteParts.push("1í†¤ ë¯¸ë§Œ ë°´ë”©"); if (projectInfo.note) noteParts.push(projectInfo.note);
                wsData.push([noteParts.join(', ')]); 
                wsData.push([]);
                const headerRow = ['ìˆœë²ˆ', 'ë‘ê»˜', 'ì¥ë³€', 'ë‹¨ë³€', 'ê¸¸ì´(ì›ë³¸)', 'ìˆ˜ëŸ‰', 'ê¸¸ì´(ì»·íŒ…)', 'ì»·íŒ…ìˆ˜', 'ìˆ˜ëŸ‰', 'ë§ˆí‚¹', 'ë³¸ë‹¹ LOSS', 'ì´ LOSS', 'ë¹„ê³ '];
                wsData.push(headerRow);

                let seq = 1;
                const stockSummary = {}; 
                const merges = [];
                const rowStyles = {}; 
                const rowSpecs = {}; 
                let grandTotalStockQty = 0; let grandTotalCutQty = 0; let grandTotalLoss = 0;
                merges.push({ s: {r:0, c:0}, e: {r:0, c:12} }); merges.push({ s: {r:2, c:0}, e: {r:2, c:12} }); 

                // For Weight Stats & Cut Part Aggregation
                const statsMap = {}; 
                const cutPartMap = new Map(); 

                specKeys.forEach(specKey => {
                    const { plan } = results[specKey];
                    let w="?", h="?", t="?";
                    try { const dims = specKey.split(' ')[0] || ""; const thick = specKey.split(' ')[1] || ""; if (dims.includes('*')) [w, h] = dims.split('*'); else if (dims.includes('x')) [w, h] = dims.split('x'); t = thick.replace('T', ''); } catch(e){}
                    const isStandard = (w == '100' && h == '100');
                    const unitWeight = getUnitWeight(w, h, t);
                    const statKey = `${t}|${w}|${h}`;
                    if (!statsMap[statKey]) { statsMap[statKey] = { t, w, h, inputLen: 0, inputWt: 0, prodLen: 0, prodWt: 0 }; }

                    let sortedPlan = [...plan];
                    // *** PATCH: Excel Sort by Stock Length Descending ***
                    sortedPlan.sort((a, b) => {
                        if (b.stockLength !== a.stockLength) return b.stockLength - a.stockLength;
                        if (mode === 'min_rows') return b.qty - a.qty;
                        return a.remainder - b.remainder;
                    });

                    sortedPlan.forEach(group => {
                        grandTotalStockQty += group.qty;
                        grandTotalLoss += (group.remainder * group.qty);
                        const summaryKey = `${t}|${w}|${h}|${group.stockLength}`;
                        if (!stockSummary[summaryKey]) stockSummary[summaryKey] = 0;
                        stockSummary[summaryKey] += group.qty;

                        // Stats Input
                        const inL = group.stockLength * group.qty; 
                        statsMap[statKey].inputLen += inL;
                        statsMap[statKey].inputWt += (inL / 1000 * unitWeight);

                        let rowStyleType = 'rowNormal';
                        const groupStartRow = wsData.length;
                        group.parts.forEach((part, pIdx) => {
                            grandTotalCutQty += (part.count * group.qty);
                            // Stats Production
                            const outL = part.length * part.totalQty;
                            statsMap[statKey].prodLen += outL;
                            statsMap[statKey].prodWt += (outL / 1000 * unitWeight);

                            // Aggregation Logic for Marking Table
                            const partKey = `${t}|${w}|${h}|${part.length}|${part.marking}`;
                            if(cutPartMap.has(partKey)) {
                                cutPartMap.get(partKey).qty += part.totalQty;
                            } else {
                                cutPartMap.set(partKey, { t, w, h, length: part.length, qty: part.totalQty, marking: part.marking });
                            }

                            rowStyles[wsData.length] = rowStyleType;
                            rowSpecs[wsData.length] = isStandard ? 'std' : 'other'; 
                            const row = [];
                            if (pIdx === 0) { row.push(seq++, t, w, h, group.stockLength, Math.floor(group.qty)); } else { row.push(null, null, null, null, null, null); }
                            row.push(part.length, part.count, Math.floor(part.totalQty), part.marking); 
                            if (pIdx === 0) { row.push(group.remainder, group.remainder * group.qty); } else { row.push(null, null); }
                            row.push(''); wsData.push(row);
                        });
                        if (group.parts.length > 1) {
                            const groupEndRow = wsData.length - 1;
                            [0,1,2,3,4,5].forEach(c => merges.push({ s: {r: groupStartRow, c}, e: {r: groupEndRow, c} }));
                            [10,11].forEach(c => merges.push({ s: {r: groupStartRow, c}, e: {r: groupEndRow, c} }));
                            merges.push({ s: {r: groupStartRow, c: 12}, e: {r: groupEndRow, c: 12} });
                        }
                    });
                });

                const totalRowIdx = wsData.length;
                wsData.push(['í•© ê³„', null, null, null, null, Math.floor(grandTotalStockQty), 'í•© ê³„', null, Math.floor(grandTotalCutQty), null, null, grandTotalLoss, null]);
                merges.push({s:{r:totalRowIdx, c:0}, e:{r:totalRowIdx, c:4}}); merges.push({s:{r:totalRowIdx, c:6}, e:{r:totalRowIdx, c:7}}); 

                // --- 2. Side Stats Table (Starts at Q6 / Row Index 5) ---
                const statsTableData = [];
                statsTableData.push(['ì¤‘ëŸ‰ ë° ê¸¸ì´ ì§‘ê³„í‘œ', null, null, null, null, null]); // Title Row
                statsTableData.push(['ê·œê²©', 'íˆ¬ì… ê¸¸ì´(m)', 'ìƒì‚° ê¸¸ì´(m)', 'íˆ¬ì… ì¤‘ëŸ‰(kg)', 'ìƒì‚° ì¤‘ëŸ‰(kg)', 'LOSS ì¤‘ëŸ‰(kg)']); // Header Row

                const sortedStatKeys = Object.keys(statsMap).sort((a,b) => {
                    const [t1, w1, h1] = a.split('|').map(Number);
                    const [t2, w2, h2] = b.split('|').map(Number);
                    if (w1===100 && h1===100 && !(w2===100 && h2===100)) return -1;
                    if (!(w1===100 && h1===100) && w2===100 && h2===100) return 1;
                    if (w1 !== w2) return w2 - w1;
                    if (h1 !== h2) return h2 - h1;
                    return t1 - t2;
                });

                let grandInLen = 0, grandProdLen = 0, grandInWt = 0, grandProdWt = 0;
                sortedStatKeys.forEach(k => {
                    const d = statsMap[k];
                    grandInLen += d.inputLen; grandProdLen += d.prodLen; grandInWt += d.inputWt; grandProdWt += d.prodWt;
                    const specStr = `${d.w}*${d.h}*${d.t}T`;
                    const lossWt = d.inputWt - d.prodWt;
                    statsTableData.push([specStr, (d.inputLen/1000).toFixed(3), (d.prodLen/1000).toFixed(3), d.inputWt.toFixed(3), d.prodWt.toFixed(3), lossWt.toFixed(3)]);
                });
                statsTableData.push(['ì „ì²´ í•©ê³„', (grandInLen/1000).toFixed(3), (grandProdLen/1000).toFixed(3), grandInWt.toFixed(3), grandProdWt.toFixed(3), (grandInWt - grandProdWt).toFixed(3)]);

                // Inject Stats Data into wsData at Column Q (Index 16), Starting Row 6 (Index 5)
                const statsStartRow = 5; 
                const statsStartCol = 16;
                const statsEndRow = statsStartRow + statsTableData.length - 1;

                merges.push({ s: {r: statsStartRow, c: 16}, e: {r: statsStartRow, c: 21} });

                statsTableData.forEach((rowItems, rIdx) => {
                    const targetRow = statsStartRow + rIdx;
                    if (!wsData[targetRow]) wsData[targetRow] = [];
                    // Pad if needed
                    while (wsData[targetRow].length < statsStartCol) wsData[targetRow].push(null);
                    // Insert items
                    rowItems.forEach((val, cIdx) => {
                        wsData[targetRow][statsStartCol + cIdx] = val;
                    });
                });

                // --- Bottom Tables (Raw & Marking) ---
                let bottomStartRow = totalRowIdx + 3;
                while(wsData.length < bottomStartRow) wsData.push([]);

                // Left: Raw Material Table
                const rawStartRow = bottomStartRow;
                if(!wsData[rawStartRow]) wsData[rawStartRow] = [];
                wsData[rawStartRow][0] = 'ì›ë³¸'; 
                merges.push({s:{r:rawStartRow, c:0}, e:{r:rawStartRow, c:4}});
                
                if(!wsData[rawStartRow+1]) wsData[rawStartRow+1] = [];
                const rawHeaders = ['ë‘ê»˜', 'ì¥ë³€', 'ë‹¨ë³€', 'ê¸¸ì´', 'ìˆ˜ëŸ‰'];
                rawHeaders.forEach((h,i) => wsData[rawStartRow+1][i] = h);
                
                const summaryKeysSummary = Object.keys(stockSummary).sort((a,b) => {
                    const [t1, w1, h1, len1] = a.split('|').map(Number);
                    const [t2, w2, h2, len2] = b.split('|').map(Number);
                    if (w1===100 && h1===100 && !(w2===100 && h2===100)) return -1;
                    if (!(w1===100 && h1===100) && w2===100 && h2===100) return 1;
                    if (w1 !== w2) return w2 - w1;
                    if (h1 !== h2) return h2 - h1;
                    if (t1 !== t2) return t1 - t2;
                    return len2 - len1;
                });
                
                let rawTotalQtyCalc = 0;
                const summaryRowsSpecType = {};
                summaryKeysSummary.forEach((key, idx) => {
                    const [t, w, h, len] = key.split('|');
                    const qty = stockSummary[key];
                    rawTotalQtyCalc += qty;
                    const isStd = (w == '100' && h == '100');
                    const r = rawStartRow + 2 + idx;
                    if(!wsData[r]) wsData[r] = [];
                    wsData[r][0] = t; wsData[r][1] = w; wsData[r][2] = h; wsData[r][3] = len; wsData[r][4] = Math.floor(qty);
                    summaryRowsSpecType[r] = isStd ? 'std' : 'other';
                });
                const rawEndRow = rawStartRow + 2 + summaryKeysSummary.length;
                if(!wsData[rawEndRow]) wsData[rawEndRow] = [];
                wsData[rawEndRow][0] = 'í•©ê³„'; wsData[rawEndRow][4] = Math.floor(rawTotalQtyCalc);
                merges.push({s:{r:rawEndRow, c:0}, e:{r:rawEndRow, c:3}});

                // Right: Marking Table
                const allCutParts = Array.from(cutPartMap.values());
                allCutParts.sort((a, b) => {
                    if (a.t !== b.t) return b.t - a.t;
                    if (a.w !== b.w) return b.w - a.w;
                    if (a.h !== b.h) return b.h - a.h;
                    if (b.length !== a.length) return b.length - a.length;
                    return a.marking.localeCompare(b.marking);
                });

                const markTitleRowIdx = bottomStartRow; 
                const markColHeaderRowIdx = bottomStartRow + 1;
                if(!wsData[markTitleRowIdx]) wsData[markTitleRowIdx] = [];
                wsData[markTitleRowIdx][6] = 'ìƒì‚°ì œí’ˆ';
                merges.push({s:{r:markTitleRowIdx, c:6}, e:{r:markTitleRowIdx, c:11}});

                if(!wsData[markColHeaderRowIdx]) wsData[markColHeaderRowIdx] = [];
                const markHeaders = ['ë‘ê»˜', 'ì¥ë³€', 'ë‹¨ë³€', 'ê¸¸ì´', 'ìˆ˜ëŸ‰', 'ë§ˆí‚¹'];
                markHeaders.forEach((h,i) => wsData[markColHeaderRowIdx][6+i] = h);

                let markRowIdx = markColHeaderRowIdx + 1;
                let markTotalQty = 0;
                let markMergeStartRow = markRowIdx;
                
                for(let i=0; i<allCutParts.length; i++) {
                    const p = allCutParts[i];
                    markTotalQty += p.qty;
                    if (!wsData[markRowIdx]) wsData[markRowIdx] = [];
                    
                    wsData[markRowIdx][6] = p.t; wsData[markRowIdx][7] = p.w; wsData[markRowIdx][8] = p.h;
                    wsData[markRowIdx][9] = p.length; wsData[markRowIdx][10] = Math.floor(p.qty); wsData[markRowIdx][11] = p.marking;

                    const prevP = i > 0 ? allCutParts[i-1] : null;
                    if (prevP && (prevP.t !== p.t || prevP.w !== p.w || prevP.h !== p.h)) {
                        if (markRowIdx - 1 > markMergeStartRow) {
                            merges.push({s:{r:markMergeStartRow, c:6}, e:{r:markRowIdx-1, c:6}});
                            merges.push({s:{r:markMergeStartRow, c:7}, e:{r:markRowIdx-1, c:7}});
                            merges.push({s:{r:markMergeStartRow, c:8}, e:{r:markRowIdx-1, c:8}});
                        }
                        markMergeStartRow = markRowIdx;
                    }
                    markRowIdx++;
                }
                if (markRowIdx - 1 > markMergeStartRow) {
                    merges.push({s:{r:markMergeStartRow, c:6}, e:{r:markRowIdx-1, c:6}});
                    merges.push({s:{r:markMergeStartRow, c:7}, e:{r:markRowIdx-1, c:7}});
                    merges.push({s:{r:markMergeStartRow, c:8}, e:{r:markRowIdx-1, c:8}});
                }
                if (!wsData[markRowIdx]) wsData[markRowIdx] = [];
                wsData[markRowIdx][6] = 'í•©ê³„'; wsData[markRowIdx][10] = Math.floor(markTotalQty);
                merges.push({s:{r:markRowIdx, c:6}, e:{r:markRowIdx, c:9}});

                const ws = XLSX.utils.aoa_to_sheet(wsData);
                ws['!merges'] = merges;
                // Add widths for columns N,O,P,Q,R,S,T,U,V
                const colWidths = [8, 8, 8, 8, 12, 8, 8, 8, 8, 12, 15, 20, 10, 5, 5, 5, 20, 18, 18, 18, 18, 18]; 
                ws['!cols'] = colWidths.map(w => ({wch: w}));
                
                const range = XLSX.utils.decode_range(ws['!ref']);
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellRef = XLSX.utils.encode_cell({r: R, c: C});
                        if (!ws[cellRef]) ws[cellRef] = { v: "", t: "s" };
                        
                        let s = { ...CELL_STYLE };
                        const isMainTable = R <= totalRowIdx && C <= 12;
                        const isRawTable = R >= rawStartRow && C <= 4 && R <= rawEndRow;
                        const isMarkTable = R >= markTitleRowIdx && C >= 6 && C <= 11 && R <= markRowIdx;
                        // Stats Table: C 16~21, R 5 ~ statsEndRow
                        const isStatsTable = R >= statsStartRow && R <= statsEndRow && C >= 16 && C <= 21;

                        if (isMainTable) {
                            if (R === 0) s = TITLE_STYLE;
                            else if (R === 2) { 
                                if (projectInfo.isIronBanding) s = NOTE_STYLE; 
                                else s = { alignment: { horizontal: "left" } };
                            }
                            else if (R === 4) s = HEADER_STYLE;
                            else if (R === totalRowIdx) s = { ...SUM_STYLE_BLUE };
                            else if (R >= 5 && R < totalRowIdx) {
                                if (rowSpecs[R] === 'other') s = { ...STYLE_OTHER_SPEC };
                                if (C === 10) { 
                                    const cellVal = ws[cellRef].v;
                                    if (typeof cellVal === 'number' && cellVal >= 650) s = { ...STYLE_WARNING_LOSS };
                                }
                            }
                            if (R === 1 || R === 3) s.border = {};
                            if (C === 10 || C === 11) s.numFmt = "#,##0";
                            if (C === 5 || C === 8) s.numFmt = "#,##0";
                        } 
                        else if (isRawTable) {
                             if (R === rawStartRow) s = { ...HEADER_STYLE, fill: { fgColor: { rgb: "CCEEFF" } } };
                             else if (R === rawStartRow + 1) s = HEADER_STYLE;
                             else if (R === rawEndRow) s = SUM_STYLE_BLUE;
                             else { 
                                 if (summaryRowsSpecType[R] === 'other') s = { ...STYLE_OTHER_SPEC }; 
                                 if (C === 4) s.numFmt = "#,##0"; // Raw Qty
                             }
                        }
                        else if (isMarkTable) {
                            if (R === markTitleRowIdx) s = { ...HEADER_STYLE, fill: { fgColor: { rgb: "CCEEFF" } } };
                            else if (R === markColHeaderRowIdx) s = HEADER_STYLE;
                            else if (R === markRowIdx) s = SUM_STYLE_BLUE;
                            if (R > markColHeaderRowIdx && C === 10) s.numFmt = "#,##0";
                        }
                        else if (isStatsTable) {
                            if (R === statsStartRow) s = { ...HEADER_STYLE, fill: { fgColor: { rgb: "CCEEFF" } } };
                            else if (R === statsStartRow + 1) s = HEADER_STYLE;
                            else if (R === statsEndRow) s = SUM_STYLE_BLUE;
                            else s = { ...CELL_STYLE };
                            if (R > statsStartRow && C >= 17) s.numFmt = "#,##0.000";
                        }
                        else { s.border = {}; }

                        ws[cellRef].s = s;
                    }
                }

                XLSX.utils.book_append_sheet(wb, ws, `CP_${targetDong}`);
                return wb;
            };

            const saveToFirebase = async () => {
                if (!user) return alert("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.");
                const title = prompt("ì»·íŒ…í‘œ ì´ë¦„ ì…ë ¥:");
                if (!title) return;
                try {
                    const { addDoc, collection, serverTimestamp } = window.FirebaseSDK;
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const savedData = Object.keys(resultsByDong).map(key => ({ dong: key, results: resultsByDong[key] }));
                    await addDoc(collection(dbRef.current, 'artifacts', appId, 'public', 'data', 'cuttingPlans'), { 
                        title, isMultiDong: true, projectInfo, results: savedData, createdAt: serverTimestamp(), creatorId: user.uid 
                    });
                    alert("ì €ì¥ ì™„ë£Œ");
                } catch (e) { alert("ì €ì¥ ì‹¤íŒ¨: " + e.message); }
            };

            const deletePlan = async (id) => {
                 if(!confirm('ì‚­ì œí•©ë‹ˆê¹Œ?')) return;
                 try {
                     const { deleteDoc, doc } = window.FirebaseSDK;
                     const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                     await deleteDoc(doc(dbRef.current, 'artifacts', appId, 'public', 'data', 'cuttingPlans', id));
                 } catch(e) { alert("ì‚­ì œ ì‹¤íŒ¨: " + e.message); }
            };

            return (
                <div className="min-h-screen bg-gray-50 text-gray-900 font-sans flex">
                    <Sidebar viewMode={viewMode} setViewMode={setViewMode} projectInfo={projectInfo} setProjectInfo={setProjectInfo} />
                    <div className="flex-1 ml-64 p-8">
                        {viewMode === 'input' && (
                            <InputView 
                                currentDong={currentDong} dongs={dongs} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong}
                                data={getCurrentData()} updateCurrentData={updateCurrentData} activeTab={activeTab} setActiveTab={setActiveTab} 
                                customStocks={customStocks} setCustomStocks={setCustomStocks} processGridData={processGridData} handlePaste={handlePaste}
                                runAllDongs={runAllDongs} globalSettings={STANDARD_STOCKS}
                                isUserStockMode={isUserStockMode} setIsUserStockMode={setIsUserStockMode} userStockList={userStockList} setUserStockList={setUserStockList}
                            />
                        )}
                        {viewMode === 'result' && (
                            <ResultView 
                                currentDong={currentDong} dongs={dongs} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong}
                                resultsByDong={resultsByDong} runAllDongs={runAllDongs} openExcelModal={() => setIsExcelModalOpen(true)} saveToFirebase={saveToFirebase} setViewMode={setViewMode}
                            />
                        )}
                        {viewMode === 'history' && (
                            <div className="animate-fade-in">
                                <h2 className="text-xl font-bold mb-4">ì €ì¥ëœ ëª©ë¡</h2>
                                <div className="grid gap-4">
                                    {savedPlans.map(plan => (
                                        <div key={plan.id} className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm flex justify-between items-center">
                                            <div>
                                                <h3 className="font-bold text-lg">{plan.title}</h3>
                                                <p className="text-sm text-gray-500">{new Date(plan.createdAt?.seconds * 1000).toLocaleString()}</p>
                                            </div>
                                            <div className="flex gap-2">
                                                <button onClick={()=>deletePlan(plan.id)} className="text-red-500 hover:bg-red-50 p-2 rounded"><Trash2/></button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                    <ExcelExportModal isOpen={isExcelModalOpen} onClose={() => setIsExcelModalOpen(false)} onConfirm={handleExcelExport} dongs={dongs} />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>